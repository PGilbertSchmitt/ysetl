program_input = _{ SOI ~ (program | program_missing_expr) ~ EOI }
repl_input = _{ SOI ~ expr ~ EOI }

program = { "program" ~ atom ~ semicolon ~ expr ~ (semicolon ~ expr)* ~ semicolon?}
program_missing_expr = { "program" ~ atom ~ semicolon? } // Example of parse-error-catcher

WHITESPACE = _{ " " | "\t" | NEWLINE }
COMMENT = _{ dbl_slash ~ (!NEWLINE ~ ANY)* ~ (NEWLINE | EOI) }

// Keywords

null = { "null" }
true_ = { "true" }
false_ = { "false" }
newat = { "newat" }
opt = { "opt" }
value = { "value" }
func = { "func" }

mod_ = { "mod" }
div = { "div" }
inter = { "inter" }
with = { "with" }
less = { "less" }
union_ = { "union" }
in = { "in" }
notin = { "notin" }
subset = { "subset" }
not = @{ "not" ~ WHITESPACE }
and = { "and" }
or = { "or" }
impl = { "impl" }
iff = { "iff" }
exists = { "exists" }
forall = { "forall" }
choose = { "choose" }
where = { "where" }

// Non-operator Symbols
// Some of these are technically operators, but it's better
// if they don't produce tokens because they're part of a
// more complex operator, like `percent`

semicolon = _{ ";" }
colon = _{ ":" }
comma = _{ "," }
b_slash = _{ "\\" }
quote = _{ "\"" }
percent = _{ "%" }

l_brace = _{ "{" }
r_brace = _{ "}" }
l_paren = _{ "(" }
r_paren = _{ ")" }
l_brack = _{ "[" }
r_brack = _{ "]" }

// Operator symbols
// I need to use separate rules for symbols that can be either prefix or infix,
// otherwise the pratt parser has a fit.

at = { "@" }
at_pre = { "@" }
plus = { "+" }
plus_pre = { "+" }
dash = { "-" }
dash_pre = { "-" }
eq = { "=" }
pipe = { "|" }
dot = _{ "." }
hash = { "#" }
qst = { "?" }
star = { "*" }
slash = { "/" }
lodash = { "_" }
lt = { "<" }
gt = { ">" }
tilde = { "~" }
bang = { "!" }

bollocks = { ":=" }
dbl_dot = { ".." }
dbl_star = { "**" }
dbl_slash = { "//" }
dbl_qst = { "??" }
dbl_amp = { "&&" }
dbl_pipe = { "||" }
dbl_lt = { "<<" }
dbl_gt = { ">>" }
bang_eq = { "!=" }
lt_eq = { "<=" }
gt_eq = { ">=" }
arrow = { "=>" }

// Operator groups

nested_expression = { l_paren ~ expr ~ r_paren }

infix_op          = _{ ident | nested_expression }

prefix_op         = _{ dash_pre | plus_pre | at_pre | hash | bang | not }

tuple_start_op    = _{ at }

null_coal_op      = _{ dbl_qst }

reduce_op         = { percent ~ (infix_op | bin_op) }

exp_op            = _{ dbl_star }

mult_op           = _{ star | slash | mod_ | div | inter }

add_op            = _{ plus | dash | with | less | union_ }

infix_inject      = { dot ~ infix_op }

set_op            = { in | notin | subset }

compare_op        = { lt | lt_eq | gt | gt_eq | eq | bang_eq }

and_op            = { and | dbl_amp }

or_op             = { or | dbl_pipe }

impl_op           = { impl }

iff_op            = { iff }

select_op         = { exists | forall | choose }

where_op          = { where }

bin_op = _{
   | tuple_start_op
   | null_coal_op
   | exp_op
   | mult_op
   | add_op
   | reduce_op
   | infix_inject
   // | and_op
   // | or_op
   // | impl_op
}

// Literals

atom_keep = { ( ASCII_ALPHANUMERIC | lodash )+ }
atom = ${
   colon ~ atom_keep
}

number_base = @{ ASCII_DIGIT+ }
number_decimal = @{ (dot ~ ASCII_DIGIT+)? }
number_exp = @{ ((^"e" | ^"f") ~ (plus | dash)? ~ ASCII_DIGIT+)? }
number = ${
   number_base
   ~ number_decimal
   ~ number_exp
}

string_char = {
   !(quote | b_slash) ~ ANY
   | b_slash ~ ( quote | b_slash | "n" | "t" )
}
string_inner = @{ string_char* }
string = ${ quote ~ string_inner ~ quote }

ident = @{ (ASCII_ALPHA | lodash) ~ (ASCII_ALPHANUMERIC | lodash)* }

// Expressions

primary = _{
   | null // More ubiquitous than "OM"
   | newat
   | true_
   | false_
   | atom
   | number
   | string
   | ident // Must follow primary keywords and function literal
   | nested_expression
}

empty_call = { "()" }

bin_expr = { prefix_op* ~ primary ~ empty_call* ~ (bin_op ~ prefix_op* ~ primary ~ empty_call*)* }

expr = _{ bin_expr }
