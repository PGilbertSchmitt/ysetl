program_input = _{ SOI ~ (program | program_missing_expr) ~ EOI }
repl_input = _{ SOI ~ expr ~ EOI }

program = { "program" ~ atom ~ semicolon ~ expr ~ (semicolon ~ expr)* ~ semicolon?}
program_missing_expr = { "program" ~ atom ~ semicolon? } // Example of parse-error-catcher

WHITESPACE = _{ " " | "\t" | NEWLINE }
__ = { WHITESPACE }
COMMENT = _{ dbl_slash ~ (!NEWLINE ~ ANY)* ~ (NEWLINE | EOI) }

// Keywords

null = { "null" }
true_ = { "true" }
false_ = { "false" }
newat = { "newat" }
opt = { "opt" }
value = { "value" }
func = { "func" }

mod_ = @{ "mod" ~ __ }
div = @{ "div" ~ __ }
inter = @{ "inter" ~ __ }
with = @{ "with" ~ __ }
less = @{ "less" ~ __ }
union_ = @{ "union" ~ __ }
in = @{ "in" ~ __ }
notin = @{ "notin" ~ __ }
subset = @{ "subset" ~ __ }
not = @{ "not" ~ __ }
and = @{ "and" ~ __ }
or = @{ "or" ~ __ }
impl = @{ "impl" ~ __ }
iff = @{ "iff" ~ __ }
exists = @{ "exists" ~ __ }
forall = @{ "forall" ~ __ }
choose = @{ "choose" ~ __ }
where = @{ "where" ~ __ }

// Non-operator Symbols
// Some of these are technically operators, but it's better
// if they don't produce tokens because they're part of a
// more complex operator, like `percent` or `bollocks`

semicolon = _{ ";" }
colon = _{ ":" }
comma = _{ "," }
b_slash = _{ "\\" }
quote = _{ "\"" }
percent = _{ "%" }
pipe = _{ "|" }
dot = _{ "." }

l_brace = _{ "{" }
r_brace = _{ "}" }
l_paren = _{ "(" }
r_paren = _{ ")" }
l_brack = _{ "[" }
r_brack = _{ "]" }

bollocks = _{ ":=" }
dbl_slash = _{ "//" }
dbl_dot = _{ ".." }

// Operator symbols
// I need to use separate rules for symbols that can be either prefix or infix,
// otherwise the pratt parser has a fit.

at = { "@" }
at_pre = { "@" }
plus = { "+" }
plus_pre = { "+" }
dash = { "-" }
dash_pre = { "-" }
eq = { "=" }
hash = { "#" }
qst = { "?" }
star = { "*" }
slash = { "/" }
lodash = { "_" }
lt = { "<" }
gt = { ">" }
tilde = { "~" }
bang = { "!" }

dbl_eq = { "==" }
dbl_star = { "**" }
dbl_qst = { "??" }
dbl_amp = { "&&" }
dbl_pipe = { "||" }
dbl_lt = { "<<" }
dbl_gt = { ">>" }
bang_eq = { "!=" }
lt_eq = { "<=" }
gt_eq = { ">=" }
arrow = { "=>" }

// Operator groups

nested_expression = { l_paren ~ expr ~ r_paren }

infix_op          = _{ ident | nested_expression }

prefix_op         = _{ dash_pre | plus_pre | at_pre | hash | bang | not }

tuple_start_op    = _{ at }

null_coal_op      = _{ dbl_qst }

reduce_op         = { percent ~ (infix_op | bin_op) }

exp_op            = _{ dbl_star }

mult_op           = _{ star | slash | mod_ | div | inter }

add_op            = _{ plus | dash | with | less | union_ }

infix_inject      = { dot ~ infix_op }

set_op            = _{ in | notin | subset }

compare_op        = _{ lt | lt_eq | gt | gt_eq | dbl_eq | bang_eq }

and_op            = _{ and | dbl_amp }

or_op             = _{ or | dbl_pipe }

impl_op           = _{ impl }

iff_op            = _{ iff }

select_op         = _{ exists | forall | choose }

where_op          = _{ where }

bin_op = _{
   | tuple_start_op
   | null_coal_op
   | exp_op
   | mult_op
   | add_op
   | reduce_op
   | infix_inject
   // | and_op
   // | or_op
   // | impl_op
}

// Literals

atom_keep = { ( ASCII_ALPHANUMERIC | lodash )+ }
atom = ${
   colon ~ atom_keep
}

number_base = @{ ASCII_DIGIT+ }
number_decimal = @{ (dot ~ ASCII_DIGIT+)? }
number_exp = @{ ((^"e" | ^"f") ~ (plus | dash)? ~ ASCII_DIGIT+)? }
number = ${
   number_base
   ~ number_decimal
   ~ number_exp
}

string_char = {
   !(quote | b_slash) ~ ANY
   | b_slash ~ ( quote | b_slash | "n" | "t" )
}
string_inner = @{ string_char* }
string = ${ quote ~ string_inner ~ quote }

ident = @{ (ASCII_ALPHA | lodash) ~ (ASCII_ALPHANUMERIC | lodash)* }

tuple_literal = { l_brack ~ former? ~ r_brack }

set_literal = { l_brace ~ former? ~ r_brace }

// Expressions

primary = _{
   | null // More ubiquitous than "OM"
   | newat
   | true_
   | false_
   | atom
   | number
   | string
   | ident // Must follow primary keywords and function literal
   | tuple_literal
   | set_literal
   | nested_expression
}

bin_expr = { prefix_op* ~ primary ~ selector* ~ (bin_op ~ prefix_op* ~ primary ~ selector*)* }

expr = _{ bin_expr }

// Special sub-expressions

expr_list = _{ expr ~ (comma ~ expr)* ~ comma? }

range_start = { expr? }
range_end = { expr? }
range = _{ range_start ~ dbl_dot ~ range_end }

// Selectors

fn_call = { l_paren ~ expr_list? ~ r_paren }

range_call = { l_paren ~ range ~ r_paren }

pick_call = { l_brace ~ expr_list ~ r_brace }

selector = _{ fn_call | range_call | pick_call }

// Bound

bound = _{
   | tilde
   | ident
   | (l_brack ~ bound_list ~ r_brack)
}

/*
eg:
~
foo
[foo,bar,~,[baz,far]]
*/

bound_list = { bound ~ (comma ~ bound)* ~ comma? }

// Iterator

in_iterator = { bound_list ~ in ~ expr }

select_iterator_single = { bound ~ eq ~ ident ~ l_paren ~ bound_list ~ r_paren }

select_iterator_multi = { bound ~ eq ~ ident ~ l_brace ~ bound_list ~ r_brace }

single_iterator = _{
   | in_iterator
   | select_iterator_single
   | select_iterator_multi
}

iterator_list = { single_iterator ~ (comma ~ single_iterator)* ~ comma? }

iterator = { iterator_list ~ (pipe ~ expr)? }

// Formers

iterator_former = { expr ~ colon ~ iterator }

interval_range_former = { expr ~ comma ~ range }

range_former = { range }

literal_former = { expr_list }

former = _{
   | iterator_former
   | interval_range_former
   | range_former
   | literal_former
}
