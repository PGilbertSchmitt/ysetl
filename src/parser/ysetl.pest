program_input = _{ SOI ~ (program | program_missing_expr) ~ EOI }
repl_input = _{ SOI ~ expr ~ EOI }

program = { "program" ~ atom ~ semicolon ~ expr ~ (semicolon ~ expr)* ~ semicolon?}
program_missing_expr = { "program" ~ atom ~ semicolon? } // Example of parse-error-catcher

WHITESPACE = _{ " " | "\t" | NEWLINE }
COMMENT = _{ dbl_slash ~ (!NEWLINE ~ ANY)* ~ (NEWLINE | EOI) }

// Keywords

null = { "null" }
true_ = { "true" }
false_ = { "false" }
newat = { "newat" }
opt = { "opt" }
value = { "value" }
func = { "func" }

mod_ = { "mod" }
div = { "div" }
inter = { "inter" }
with = { "with" }
less = { "less" }
union_ = { "union" }
in = { "in" }
notin = { "notin" }
subset = { "subset" }
not = { "not" }
and = { "and" }
or = { "or" }
impl = { "impl" }
iff = { "iff" }
exists = { "exists" }
forall = { "forall" }
choose = { "choose" }
where = { "where" }

// Non-operator Symbols

semicolon = _{ ";" }
colon = _{ ":" }
comma = _{ "," }
b_slash = _{ "\\" }

l_brace = _{ "{" }
r_brace = _{ "}" }
l_paren = _{ "(" }
r_paren = _{ ")" }
l_brack = _{ "[" }
r_brack = _{ "]" }

// Operator symbols

at = { "@" }
eq = { "=" }
pipe = { "|" }
dot = { "." }
hash = { "#" }
qst = { "?" }
star = { "*" }
slash = { "/" }
plus = { "+" }
dash = { "-" }
lodash = { "_" }
quote = { "\"" }
lt = { "<" }
gt = { ">" }
percent = { "%" }
tilde = { "~" }

bollocks = { ":=" }
dbl_dot = { ".." }
dbl_star = { "**" }
dbl_slash = { "//" }
dbl_qst = { "??" }
dbl_amp = { "&&" }
dbl_pipe = { "||" }
dbl_lt = { "<<" }
dbl_gt = { ">>" }
bang_eq = { "!=" }
lt_eq = { "<=" }
gt_eq = { ">=" }
arrow = { "=>" }

// Operator groups

unary_op        = _{ hash | dash | plus | at }

tuple_start_op  = _{ at }

expr_or_op      = _{ qst }

reduce_op       = _{ percent }

exp_op          = _{ dbl_star }

mult_op         = _{ star | slash | mod_ | div | inter }

add_op          = _{ plus | dash | with | less | union_ }

infix_id_func   = _{ ident }
infix_expr_func = _{ l_paren ~ expr ~ r_paren }
infix_op        = _{ dot ~ (infix_id_func | infix_expr_func) }

set_op          = _{ in | notin | subset }

compare_op      = _{ lt | lt_eq | gt | gt_eq | eq | bang_eq }

not_op          = _{ not }

and_op          = _{ and | dbl_amp }

or_op           = _{ or | dbl_pipe }

impl_op         = _{ impl }

iff_op          = _{ iff }

select_op       = _{ exists | forall | choose }

where_op        = _{ where }

bin_op = _{
     exp_op
   | mult_op
   | add_op
   | and_op
   | or_op
   | impl_op
   | infix_op
}

// Literals

atom_keep = { ( ASCII_ALPHANUMERIC | lodash )+ }
atom = ${
   colon ~ atom_keep
}

number_dash = { dash? }
number_base = { ASCII_DIGIT+ }
number_decimal = { (dot ~ ASCII_DIGIT+)? }
number_exp = { ((^"e" | ^"f") ~ (plus | dash)? ~ ASCII_DIGIT+)? }
number = ${
   number_dash
   ~ number_base
   ~ number_decimal
   ~ number_exp
}

string_char = {
   !(quote | b_slash) ~ ANY
   | b_slash ~ ( quote | b_slash | "n" | "t" )
}
string_inner = @{ string_char* }
string = ${ quote ~ string_inner ~ quote }

ident = @{ (ASCII_ALPHA | lodash) ~ (ASCII_ALPHANUMERIC | lodash)* }

// Expressions

primary = _{
     null // More ubiquitous than "OM"
   | newat
   | true_
   | false_
   | atom
   | number
   | string
   | ident // Must follow primary keywords and function literal
   | nested_expression // The absolute highest priority
}

// This precencende climbing method is what I'm used to with PEG parsers
// However, it appears to use a lot of memory due to a primary being wrapped
// with layers and layers of other expressions. Maybe I need to use a Pratt
// parser instead.

nested_expression = _{ l_paren ~ expr ~ r_paren }

null_coal_expr = { primary ~ (dbl_qst ~ primary)* }

tuple_start_expr = { null_coal_expr ~ (at ~ null_coal_expr)? }

reduce_expr = { tuple_start_expr ~ (percent ~ bin_op ~ tuple_start_expr)? }

exponent_expr = { reduce_expr ~ (exp_op ~ reduce_expr)* }

mult_expr = { exponent_expr ~ (mult_op ~ exponent_expr)* }

add_expr = { mult_expr ~ (add_op ~ mult_expr)* }

expr = _{ add_expr }

// expr_list = { expr ~ (comma ~ expr)* }
